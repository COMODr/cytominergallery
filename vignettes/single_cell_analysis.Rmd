---
title: "Analyze single-cell data"
author: "Allen Goodman and Shantanu Singh"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analyze single-cell data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette demonstrates how to analyze single-cell data from a
morphological profiling experiment. 

The images were analyzed using [CellProfiler](http://cellprofiler.org).

This vignette assumes that 
- the single-cell data `110000106828_sub_1.sqlite` have 
been created using `ingest` and stored in `~/Downloads`.
- the metadata `metadata.csv` has the columns `WELLTYPE_CODE`, `BARCODE`, and 
`WELL`, and is stored in `~/Downloads`.



```{r libraries, message=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)
library(stringr)
```


# Load data

First, load the data. The data is contained in 4 tables named `Image`, 
`Cytoplasm`, `Cells`, and `Nuclei`. The code below joins these tables to 
create a single table named `object`. 

```{r load, message=FALSE}
backend <- file.path(Sys.getenv("HOME"), "Downloads", "110000106828_sub_1.sqlite")

db <- src_sqlite(path = backend)

image <- tbl(src = db, "image")

object <-
  tbl(src = db, "Cells") %>%
  inner_join(tbl(src = db, "Cytoplasm"),
                    by = c("TableNumber", "ImageNumber", "ObjectNumber")) %>%
  inner_join(tbl(src = db, "Nuclei"),
                    by = c("TableNumber", "ImageNumber", "ObjectNumber"))

object %<>% inner_join(image, by = c("TableNumber", "ImageNumber"))
```

In this table, the measurement columns start with `Nuclei_`, `Cells_`, or 
`Cytoplasm_`. 

```{r}
variables <-
  colnames(object) %>%
  stringr::str_subset("^Nuclei_|^Cells_|^Cytoplasm_")
```

How many variables?

```{r}
print(length(variables))
```

How many cells?

```{r}
object %>% 
  count() %>%
  knitr::kable(caption = "No. of cells")
```

Let's join the metadata

```{r}
metadata <- 
  readr::read_csv("~/Downloads/metadata.csv") %>%
  select(BARCODE, WELL, WELLTYPE_CODE) %>%
  rename(image_Metadata_Barcode = BARCODE,
         image_Metadata_Well = WELL,
         image_Metadata_Type = WELLTYPE_CODE)

head(metadata)

metadata <- 
  dplyr::copy_to(db, 
                 metadata, 
                 indexes = list("image_Metadata_Type")
                 )
object %<>%
  inner_join(metadata)
```

# Feature selection

Next, lets filter the set of features based on various measures of quality 

Remove features that have near-zero variance. 

```{r message=FALSE}
futile.logger::flog.info("start")

object <-
  cytominer::select(
    population = object,
    variables = variables,
    sample = object %>% filter(image_Metadata_Well == "A01") %>% collect(),
    operation = "variance_threshold"
  ) 

variables <-
  colnames(object) %>%
  str_subset("^Nuclei_|^Cells_|^Cytoplasm_")

futile.logger::flog.info("end")
```

Filter based on correlation between features. The morphological features 
extracted contain several highly correlated groups. We want to to prune the set
of features, retaining only one feature from each of these highly correlated
sets. The function `correlation_threshold` provides an approximate (greedy)
solution to this problem. After excluding the features, no pair of features 
have a correlation greater than `cutoff` indicated below.

```{r message=FALSE}
futile.logger::flog.info("start")

object <-
  cytominer::select(
    population = object,
    variables = variables,
    sample = object %>% filter(image_Metadata_Well == "A01") %>% collect(),
    operation = "correlation_threshold",
    cutoff = 0.95) 

variables <-
  colnames(object) %>%
  str_subset("^Nuclei_|^Cells_|^Cytoplasm_")

futile.logger::flog.info("end")
```

# Normalize with reference to control

We need to normalize the data so that

- features are on the same scale

- plate-to-plate variation is reduced

The default for doing this is `standardization`. Here, we take all the cells
from control wells in the experiment and compute normalizations parameters 
from that (in this case, just the mean and s.d.) and then apply it to 
the whole dataset (i.e. the population)

```{r message=FALSE}
futile.logger::flog.info("start")

object %<>% collect()

object <-
  cytominer::normalize(
    population = object,
    variables = variables,
    strata =  c("image_Metadata_Barcode"),
    sample = object %>% filter(image_Metadata_Well == "A01") 
  )

futile.logger::flog.info("end")
```

In some cases, we may have features that have no variance at all (e.g. Euler 
number). If these features have not already been removed by this stage, the 
standardization step will results in all values for that feature being NA (
because s.d. = 0). Lets remove them:

```{r message=FALSE}
futile.logger::flog.info("start")

object <-
  cytominer::select(
      population = object,
      variables = variables,
      operation = "drop_na_columns"
  )

variables <-
  colnames(object) %>%
  str_subset("^Nuclei_|^Cells_|^Cytoplasm_")

futile.logger::flog.info("end")
```


## Transform

We may want to tranform the data so that assumptions we may later make about the 
data distribution are satisfied (e.g. Gaussianity). The default here is 
`generalized_log`.

```{r}
futile.logger::flog.info("start")

object <-
  cytominer::transform(
    population = object,
    variables = variables
  )

futile.logger::flog.info("end")
```

# Summarize measurements per well

Before aggregating the data, let's filter it down to one well and plot the 
histogram of a single feature:

```{r fig.width=5, fig.height=5}
object %>% 
  filter(image_Metadata_Well == "A01") %>%
  select(Nuclei_Intensity_IntegratedIntensity_Hoechst) %>% 
  collect() %>% {
    ggplot(., aes(Nuclei_Intensity_IntegratedIntensity_Hoechst)) + 
      geom_histogram(binwidth = .1)
    }

```


Now let's summarize the data by grouping by well and computing averages. 

```{r message=FALSE}
futile.logger::flog.info("start")

profiles <-
  cytominer::aggregate(
    population = object,
    variables = variables,
    strata = c("image_Metadata_Barcode", "image_Metadata_Well"),
    operation = "mean"
  )

profiles %<>%
  collect()

futile.logger::flog.info("end")
```

How many wells?

```{r}
profiles %>% 
  count() %>%
  knitr::kable(caption = "No. of wells")
```


Let's plot the relationship between a pair of variables from this summarized data

```{r fig.width=6, fig.height=5, message=FALSE}
p <- 
  ggplot(profiles, aes(Cells_Intensity_IntegratedIntensity_Hoechst, Nuclei_AreaShape_Area)) + 
  geom_point()

print(p)
```

